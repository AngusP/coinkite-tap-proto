#
# test all available libraries and compare their results with each other and expected results (hardcoded data)
# if only ecdsa is available it will be tested against expected results
#

# created with os.urandom(32)
sk_list = [
    b'\xb7\x11#%\xc3wdr\xe2\xa6\xff\x84\xf3\xa5R\xac\x97\x06\xbb\xaa\xb6\xad\xb1\x9f\xde\xc0^\x8a\x06\xe7\x7f\x96',
    b'2\x1f\xc9\x0bU\x9a9\xee\x9fQ|\x8b\xfbO\xfe?\xc0~\x99\xec\xb7\x10\x82\xcf\x84P\x02\xac(\xf9\xfc\x81',
    b'\xd3\x18M\xcdn\xf7"\x88\xba<\x8c\x01h\x9c.0\xe6Z\xa6>5\\\x99t\xcb\x98\xd4\xe2\xda\r\xc6\xfa',
    b'i\xc4\xdc0\xb9\x18\xb3/\xdc0/\x9d0\x16\xd2\x08\x9d/\x00\x0bVC\xdeH\xd9\xb7\xd1\x0f\x8e\xd8\xc2\xad',
    b'\x98\x96jd\x8f\xfda\xa0\x84\x1e\xfdE\xa2\x8e\x85_\xecY\x85K8\xfa\xe2b\x89?\x8e;\x92\xa8c\x91',
    b'\xbb\x07i\x97\xd2&p\xbb\xa1\x14z9&\x1bU9lQ>Gi\xd6\xb3\xe0(T\xae\xaf\xc9\x17\xf1)',
    b';E\x9e\x84\x8d\xd2\x14\xa3#[\xf5\x9d\x89<9\xdc\x9f\x06\xe1\x95\x15\x00R\xd3\xaa\xc3jtvbU\x88',
    b'\x05\xf7\xd0W\xd3\xcf\xe6\xf54\x11\xae\xe7\xbe\x93\xfb\x15\x92\x9e\xe5`~\xb77%\x0f\xac}\x14\x07\xfd\xc5\xb2',
    b'\x8a\xf8\xeeb\xbcw\x92w\x07XY\x8b\x1b3SNo\x1a\xadw\xe4 \x98\x9fq\xd9\x16z\xf2\xc93\x97',
    b'\xde\x06\x14\x124e\x04>)0\r\xecM>&\xe4\xb1\xb5\xe4\x8c.\xff2\xec#\x99\x07:zl\rO'
]
# created with hashlib.sha256(os.urandom(32)).digest()
msg_digest_list = [
    b'3\xa7=Q\x1f\xb3\xfa)>i\x8f\xb2\x8f6\xd2\x97\x9eW\r5\x0b\x82\x0e\xd3\xd6?\xf4G]\x14Fd',
    b'\xa3"\xedl Y$\x80|z\x84\x08\x98\xf9\x92\xd0\xc4\x1d/\xb5n\xfe\xd3\xa0"}Gj$\xa62\x80',
    b'-\xb4v\x8f\xbe\x9d\x16<N\xb9\x9a\x9fU\x1f\x9b\xf5\x03\xeaL\x8f\xd8qU>;\xf6\xa8\xa5]:\xc8]',
    b'\xbfz\xda\xbcu\x81\xd3Vs\xae\x8f\xab\x9a\x80w\x10\xd9\xba~K:\xbe\x92\'\xe0\xcd\x84"\xebWv\x0c',
    b'\x91j\x85\x9b\xb17\x0f\th{\xab\x1b\xec\xd2\x93\xd5\xc7\xcd\xa7Ou\xd7\x9b"\x87\x8e@6\xba\xc1\xa9\xbf',
    b'\xd2C\xe8\xe7\xf1Q\xa0D\xf30!\xe5 A\xbe\x8b#6\x00\x18:\x0b\xa4\x8a&\xc4\xc6?l+\x8b`',
    b"WB\x9e\xb9q\x9c\xe3\xf8\xa7\x11@A\xb4\xc1\x93\x03\x96'B\xb6\xc9\xb5\xce\xa7\xc2\x9f\xc1\x95!\x14pU",
    b'B\x16\xc8VP\xdb\xb3\x84\xb5\x97\r\xbb\x1c\xf5\x0686GvG\x8f\xfd\xeb\xfa\xbb\xbdM\n\x16o\xf8]',
    b'zj\x07)c\x8a\xcc\x9bo\x9b\xc4\x05^\xf2\xa4\x8f\xcb\xa8\t\xae,g\x1eT\xd7M\xd4"\xc8\x98cF',
    b'\xe7\x85\xfbJ\xbcY\x97.\x03\x0c\xec\xe0O\xdaj\x020g\x80dB[\xe3d\xebe\xda\xd8\x0e\xef2q'
]
# expected pubkey derived from sk_list by index
expected_pks = [
    b'\x02\xb7\r.\x82\x1c\x97Q\xec>)&\x11Vf\xbcL\xe4Y_\xe8\xbd\xc7\x8dL?\xb0\x1e\x8b\xc3\x08\xc6\xf6',
    b'\x03\xae&|7Sx\x08}\xc3AyN\x91N\x97h\x8e\x9b\xd6\xee\xbf*|\xee\xb3>\xa3\xb6fb[\xc9',
    b'\x02.\xed\xfe}\xce\xa4\xa3tRV4\xc8|\x1a\x8bd\x8c\x19\xa7N\x7f\x9bW\x81`\xa6*\x04\xdd\xb1\x10N',
    b'\x02M\\X\x817\x14\xc2\xe3Ah\x86U\x03\xca\xcb\xb5\x16\xbb\xee\xdb7B\xb9e\xe2\xd5\xcbE\x8aH\xde-',
    b'\x02\xa7\x14\xea\x8b\x1e\xf2\xdb\xa1p\xe8\x93\xd7\xd0\x97}\xc4\xda\xa3\x1a\x0cu\xc9a\r-\xcdR\xa8\xe7\xd1&\xe2',
    b'\x03J\xa1"\xc5\xeb\xb8P\xdft\xab\x80\xd5A\xd6\x1d\x01&*\x8f\xc8\xf6\xeaf\xdcc\xce1\xd4e~,\xcb',
    b'\x02\x91\x16q\xed\x0e\x98\xe0:g\xe9\x01\xed\t\xc8ro\xb0DM\xf0\x87\xae\x9e\xfb\x86f\x15\xfb\xa1\xb7b\xee',
    b'\x03\xcbe\x1d-\x97.\xab\xb6\xd4Z\x1f6\xd2\x85K\x18.\x0e\xa6\xee?\x9c\xaaF\t\xbf\x93\xbb\xa0\x83\x8f=',
    b'\x03\xd8E\xde\xe5\x80\xee7\x03\x90\x13b\xb6\xadL\xf9\xadx\xe2\xf0\x17L6\xe7\xc3\xcef\xcdHlu \xf7',
    b'\x03\x8d\xf0!\xc4\xca\xe7\xd29X\x15\xa9\x8dLD$\xfb\x7fV\xfd\x07\xa5\xb4\x7f\xad\x93\xde2U\x8edP\xfe'
]
# expected deterministic signature over same index of sk_list and msg_digest_list
expected_determinist_signatures = [
    b'\xdbf\x87\x14v\xb3Z\xc0\xa6\ri\tE\x9a\xc5+\x0c\xba\tg\xe6\xe9\x04\x07ROe\x04n7\xa6D?\x98\xb0\xdam\xe27-Pt\xf4\x19\x8a\x18z\x0b\xc0\xa9\xd8(E\xa1#\xbfEdy\xa9\xefy\xa9H',
    b'\xdeiZ\x9e\x9c\x98\xe3\x17I*\xff\xec\xb4>\x0b\xce\x9d\xae4u_\xed\xf2\xa3g\xf6G\xd7{\xd8\xb5\xf09\x8c\x86l\xdf\xf7\xb0\x7f\x9e;\x8a\x03\x89\xe3G\x11\xce\xb9=\x1fjo\xd7\x84]`V\x00sk.\xd9',
    b'\xb4CJ9f\xb4~\xa5\xc2\xa2dJ\x94@\x1a?\x95\x15\xd9\x80\xe9\xd9\xe9|a;\x18=;\xe8?3\x0e\xa2\t~\xec9\n\xbc\xb0\x9f\xef=\xa8Ed\x89\xd6T=\x1b\x16\xf8\x06M\xce\x13\xf2\xb0\xe0\xeb\x8d\xd0',
    b'\x8a\x91\xb6\xea\xd4\x1er)\xf3\x01\x8c\x96H\xd1\xfaQ]-U\xc4\xbc\xcdz\x9a\x1c\xc1\n\x0b!,\xe0\xf6\x04\xe1\x1d\xc7\xd5\xe9\xbd\xd2\xc7n\xfc/+7\xab\xf3\x7f\xe9O\xc7\xb7\x95\x80?\r\x934\x92\x9b\x06}\xf6',
    b'V\xf2\xb9\xddR\x93\xb2\x1f\x1e\xfc\xac\xd1x\x0c\xc8\x8a/\xacQ\xb5l\x84\xa9\xcb|r\xa1\xd2K\xf5~~=x\x8a\x069B\x7f&R\xa8\x18m\xa658\xbe ,\xac\xde\xde\x92.\xcep\xa9\xf2\xf7\x10\xa0\xd0\x9f',
    b"\x0e^2\xf6\x1dX\xe2\x1f\x12m\xae\xfd\xe9k\xacaS\x94\x7f\xafL\x95\xef)\xd5\xedXY\xf9'\x96lsC\x1bN2QM\xf1l\xed\xf3(k\x1f\x98\xdd\xf7\xcc\xe2*?\x93\x85\x0f\xd1\\\xcb$;\x11\xe19",
    b'm\x86:\xe2K\x06c\xed\x82\xf2\x9d,\xb8\xfa_\xbf4g\r\xf8u@\xbb\xc8\x0f8\xb6\x84\x89Q\xdd\x89nU\x1b\x99\x9c.q\xf9\xd1K\xd7D\x91\xb0\x18\xd8\xf0r\xd8\x8e\t\xa4\xd3\x92\x19\xd65631\xfb\x1f',
    b'\x16\x84\xee\xa2\xb4 YM\x0e\xe8\r\xc6=\x98 !\x99\xa0\xc8.F\xb3B\xa5\xf9\xa4cr\x0c\x9fm?E\xdd\x1a)\xad\xfe\xe0I\xcbe\xd7\xc2V\xd3G\xd5\xa1\xe4\xd7\xe0#\xb0`4\x13`\xa1\xf6\x82r\xd3z',
    b'\xe6\x07Z\t\x7fWCB\x18\x8a\xa5\x00rz/\xf7\xbcd\x91\xe4\xd2\xd0}T\x17J\xc6\xe2\x93\xe8\xbe\xffJ\x9b\xab\xda\xdaY8\x8f\x8c\x97\x82Z\x05\x19\\\x87)\x19\xe0\x0f\x05\x92Lk\x95}\xe50\xf1\xfb\xe0n',
    b'IBH96\x82p{]\x03\x03\xf9\xd3\xd8\xf5\x9f3\x10a\xc6m\x06\x18\x1a\x9f\xd9\xfb\x0eeHH\xb3W\x841\xc1gl\xa8\x90[D\xd6\xfd\xd9\xa0\xfa%\x83\xfbk-\xbd\xd0\x97\x0c\x872>\xbdO\xbco\xba'
]
# expected deterministic recoverable signature over same index of sk_list and msg_digest_list
expected_deterministic_recoverable_signatures = [
    b'\x1f\xdbf\x87\x14v\xb3Z\xc0\xa6\ri\tE\x9a\xc5+\x0c\xba\tg\xe6\xe9\x04\x07ROe\x04n7\xa6D?\x98\xb0\xdam\xe27-Pt\xf4\x19\x8a\x18z\x0b\xc0\xa9\xd8(E\xa1#\xbfEdy\xa9\xefy\xa9H',
    b'\x1f\xdeiZ\x9e\x9c\x98\xe3\x17I*\xff\xec\xb4>\x0b\xce\x9d\xae4u_\xed\xf2\xa3g\xf6G\xd7{\xd8\xb5\xf09\x8c\x86l\xdf\xf7\xb0\x7f\x9e;\x8a\x03\x89\xe3G\x11\xce\xb9=\x1fjo\xd7\x84]`V\x00sk.\xd9',
    b'\x1f\xb4CJ9f\xb4~\xa5\xc2\xa2dJ\x94@\x1a?\x95\x15\xd9\x80\xe9\xd9\xe9|a;\x18=;\xe8?3\x0e\xa2\t~\xec9\n\xbc\xb0\x9f\xef=\xa8Ed\x89\xd6T=\x1b\x16\xf8\x06M\xce\x13\xf2\xb0\xe0\xeb\x8d\xd0',
    b'\x1f\x8a\x91\xb6\xea\xd4\x1er)\xf3\x01\x8c\x96H\xd1\xfaQ]-U\xc4\xbc\xcdz\x9a\x1c\xc1\n\x0b!,\xe0\xf6\x04\xe1\x1d\xc7\xd5\xe9\xbd\xd2\xc7n\xfc/+7\xab\xf3\x7f\xe9O\xc7\xb7\x95\x80?\r\x934\x92\x9b\x06}\xf6',
    b'\x1fV\xf2\xb9\xddR\x93\xb2\x1f\x1e\xfc\xac\xd1x\x0c\xc8\x8a/\xacQ\xb5l\x84\xa9\xcb|r\xa1\xd2K\xf5~~=x\x8a\x069B\x7f&R\xa8\x18m\xa658\xbe ,\xac\xde\xde\x92.\xcep\xa9\xf2\xf7\x10\xa0\xd0\x9f',
    b"\x1f\x0e^2\xf6\x1dX\xe2\x1f\x12m\xae\xfd\xe9k\xacaS\x94\x7f\xafL\x95\xef)\xd5\xedXY\xf9'\x96lsC\x1bN2QM\xf1l\xed\xf3(k\x1f\x98\xdd\xf7\xcc\xe2*?\x93\x85\x0f\xd1\\\xcb$;\x11\xe19",
    b'\x1fm\x86:\xe2K\x06c\xed\x82\xf2\x9d,\xb8\xfa_\xbf4g\r\xf8u@\xbb\xc8\x0f8\xb6\x84\x89Q\xdd\x89nU\x1b\x99\x9c.q\xf9\xd1K\xd7D\x91\xb0\x18\xd8\xf0r\xd8\x8e\t\xa4\xd3\x92\x19\xd65631\xfb\x1f',
    b' \x16\x84\xee\xa2\xb4 YM\x0e\xe8\r\xc6=\x98 !\x99\xa0\xc8.F\xb3B\xa5\xf9\xa4cr\x0c\x9fm?E\xdd\x1a)\xad\xfe\xe0I\xcbe\xd7\xc2V\xd3G\xd5\xa1\xe4\xd7\xe0#\xb0`4\x13`\xa1\xf6\x82r\xd3z',
    b'\x1f\xe6\x07Z\t\x7fWCB\x18\x8a\xa5\x00rz/\xf7\xbcd\x91\xe4\xd2\xd0}T\x17J\xc6\xe2\x93\xe8\xbe\xffJ\x9b\xab\xda\xdaY8\x8f\x8c\x97\x82Z\x05\x19\\\x87)\x19\xe0\x0f\x05\x92Lk\x95}\xe50\xf1\xfb\xe0n',
    b'\x1fIBH96\x82p{]\x03\x03\xf9\xd3\xd8\xf5\x9f3\x10a\xc6m\x06\x18\x1a\x9f\xd9\xfb\x0eeHH\xb3W\x841\xc1gl\xa8\x90[D\xd6\xfd\xd9\xa0\xfa%\x83\xfbk-\xbd\xd0\x97\x0c\x872>\xbdO\xbco\xba'
]
# expected ECDH shared secrets (index 0 = sk_list[0] and expected_pks[-1], index 1 = sk_list[1] and expected_pks[-2], ...)
expected_ecdh_shared_secrets = [
    b'\xe7\xa7\xc4S\x13+\x91\x16\x1c\x83\xfb\n\xfdl\xae\xa0\xfe-\xc6A\x9cN!lW\x07\xa4\xd7,\xbej\xe3',
    b"\x05\x9b\x83\xa3\x82'\xfa\xe9\xb72?\xf8\x94\x0e\x92\x12\x02\x99\x1d[0\x18\x1dq\xcb]\xebz\x12\x10\x10\x10",
    b'\xce\xcd\xa2`\xd6\xf9\x13H\x1d\x9a\xc1\xc0j\xd0\xbf\x92\r\xb7\xb9A\xc3\xc7a\rG\x1bl\x12\x86tpC',
    b'{\xa5\xe0|\xea\xb2\xe6\x9d\x12\xfa6\x1e\xef-+\x96\xc6\x13?\xdb\xc7:-\xf4\xd5n\x93\xfd\xc6\xe9\xd8\xfb',
    b'\x9eO2\xeb\x82\xda\xa5\x86\xd5\x18\x1a\x04\x0f\xd7\xb9\x01\t\xa6\xaf\xf2\x94]\xfe\xb4\xf6\x846\x0e\xb7\x1f\xe1\x95',
    b'\x9eO2\xeb\x82\xda\xa5\x86\xd5\x18\x1a\x04\x0f\xd7\xb9\x01\t\xa6\xaf\xf2\x94]\xfe\xb4\xf6\x846\x0e\xb7\x1f\xe1\x95',
    b'{\xa5\xe0|\xea\xb2\xe6\x9d\x12\xfa6\x1e\xef-+\x96\xc6\x13?\xdb\xc7:-\xf4\xd5n\x93\xfd\xc6\xe9\xd8\xfb',
    b'\xce\xcd\xa2`\xd6\xf9\x13H\x1d\x9a\xc1\xc0j\xd0\xbf\x92\r\xb7\xb9A\xc3\xc7a\rG\x1bl\x12\x86tpC',
    b"\x05\x9b\x83\xa3\x82'\xfa\xe9\xb72?\xf8\x94\x0e\x92\x12\x02\x99\x1d[0\x18\x1dq\xcb]\xebz\x12\x10\x10\x10",
    b'\xe7\xa7\xc4S\x13+\x91\x16\x1c\x83\xfb\n\xfdl\xae\xa0\xfe-\xc6A\x9cN!lW\x07\xa4\xd7,\xbej\xe3'
]


def pubkey_sign_verify_wally(sk, msg_digest):
    try:
        from cktap.wrap_wally import CT_sign, CT_priv_to_pubkey, CT_sig_verify
    except ImportError:
        return None, None
    pk = CT_priv_to_pubkey(sk)
    sig = CT_sign(sk, msg_digest, recoverable=False)
    ok = CT_sig_verify(pk, msg_digest, sig)
    assert ok
    return pk, sig


def ecdh_wally(sk, pk):
    try:
        from cktap.wrap_wally import CT_ecdh
    except ImportError:
        return None
    return CT_ecdh(pk, sk)


def rec_sigs_wally(sk, msg_digest):
    try:
        from cktap.wrap_wally import CT_sign, CT_sig_to_pubkey
    except ImportError:
        return None, None
    rec_sig = CT_sign(sk, msg_digest, recoverable=True)
    assert len(rec_sig) == 65
    recovered_pk = CT_sig_to_pubkey(msg_digest, rec_sig)
    return rec_sig, recovered_pk


def bip32_wally(chain_code, priv_or_pub, path):
    try:
        from cktap.wrap_wally import CT_bip32_derive
    except ImportError:
        return None
    return CT_bip32_derive(chain_code, priv_or_pub, path)


def pubkey_sign_verify_coincurve(sk, msg_digest):
    try:
        from cktap.wrap_coincurve import CT_sign, CT_priv_to_pubkey, CT_sig_verify
    except ImportError:
        return None, None
    pk = CT_priv_to_pubkey(sk)
    sig = CT_sign(sk, msg_digest, recoverable=False)
    ok = CT_sig_verify(pk, msg_digest, sig)
    assert ok
    return pk, sig


def ecdh_coincurve(sk, pk):
    try:
        from cktap.wrap_coincurve import CT_ecdh
    except ImportError:
        return None
    return CT_ecdh(pk, sk)


def rec_sigs_coincurve(sk, msg_digest):
    try:
        from cktap.wrap_wally import CT_sign, CT_sig_to_pubkey
    except ImportError:
        return None, None
    rec_sig = CT_sign(sk, msg_digest, recoverable=True)
    assert len(rec_sig) == 65
    recovered_pk = CT_sig_to_pubkey(msg_digest, rec_sig)
    return rec_sig, recovered_pk


def pubkey_sign_verify_ecdsa(sk, msg_digest):
    # pybitcointools for recoverable signatures signing/verification
    try:
        from cktap.wrap_ecdsa import CT_sign, CT_priv_to_pubkey, CT_sig_verify
    except ImportError:
        return None, None
    pk = CT_priv_to_pubkey(sk)
    sig = CT_sign(sk, msg_digest, recoverable=False)
    ok = CT_sig_verify(pk, msg_digest, sig)
    assert ok
    return pk, sig


def ecdh_ecdsa(sk, pk):
    try:
        from cktap.wrap_wally import CT_ecdh
    except ImportError:
        return None
    return CT_ecdh(pk, sk)


def rec_sigs_ecdsa(sk, msg_digest):
    try:
        from cktap.wrap_wally import CT_sign, CT_sig_to_pubkey
    except ImportError:
        return None, None
    rec_sig = CT_sign(sk, msg_digest, recoverable=True)
    assert len(rec_sig) == 65
    recovered_pk = CT_sig_to_pubkey(msg_digest, rec_sig)
    return rec_sig, recovered_pk


def bip32_ecdsa(chain_code, priv_or_pub, path):
    try:
        from cktap.wrap_wally import CT_bip32_derive
    except ImportError:
        return None
    return CT_bip32_derive(chain_code, priv_or_pub, path)


def test_pubkey_sign_verify():
    for sk, msg_digest, expected_pk, expected_sig in zip(sk_list, msg_digest_list, expected_pks, expected_determinist_signatures):
        pk_cc, sig_cc = pubkey_sign_verify_coincurve(sk, msg_digest)
        pk_wally, sig_wally = pubkey_sign_verify_wally(sk, msg_digest)
        pk_ecdsa, sig_ecdsa = pubkey_sign_verify_ecdsa(sk, msg_digest)
        all_sigs = [sig for sig in [sig_cc, sig_ecdsa, sig_wally] if sig is not None]  # filter out None results of unavailable libs
        all_pks = [pk for pk in [pk_cc, pk_ecdsa, pk_wally] if pk is not None]  # filter out None results of unavailable libs
        rr = all([sig == expected_sig for sig in all_sigs])
        if rr is False:
            import pdb;pdb.set_trace()
            x = 465465
            hh = 465456
        assert rr
        assert all([pk == expected_pk for pk in all_pks])


def test_ecdh():
    # reverse expected pubkey so we do not use sk/pk pairing
    for sk, pk, expected_ss in zip(sk_list, reversed(expected_pks), expected_ecdh_shared_secrets):
        ss_wally = ecdh_wally(sk, pk)
        ss_cc = ecdh_coincurve(sk, pk)
        ss_ecdsa = ecdh_ecdsa(sk, pk)
        all_ss = [ss for ss in [ss_cc, ss_ecdsa, ss_wally] if ss is not None]  # filter out None results of unavailable libs
        assert all([ss == expected_ss for ss in all_ss])


def test_rec_sigs():
    for sk, msg_digest, expected_pk, expected_rs in zip(sk_list, msg_digest_list, expected_pks, expected_deterministic_recoverable_signatures):
        rs_wally, rpk_wally = rec_sigs_wally(sk, msg_digest)
        rs_cc, rpk_cc = rec_sigs_coincurve(sk, msg_digest)
        rs_ecdsa, rpk_ecdsa = rec_sigs_ecdsa(sk, msg_digest)
        all_rpks = [rpk for rpk in [rpk_wally, rpk_ecdsa, rpk_cc] if rpk is not None]  # filter out None results of unavailable libs
        all_rs = [rs for rs in [rs_wally, rs_ecdsa, rs_cc] if rs is not None]  # filter out None results of unavailable libs
        assert all([rpk == expected_pk for rpk in all_rpks])
        assert all([rs == expected_rs for rs in all_rs])
